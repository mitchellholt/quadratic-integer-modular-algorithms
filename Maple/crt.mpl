read("Maple/quadratic_integers.mpl"); # Surely there's a better way to do this


# These functions are only run when the assert level is non-zero
PairwiseCoprime := proc(m :: list(integer), $) :: boolean;
    local n,i,j;
    n := nops(m);
    for i from 1 to n do for j from i + 1 to n do
        if m[i] = m[j] or m[i] = -m[j] or igcd(m[i], m[j]) <> 1 then return false; fi;
    od; od;
    return true;
end proc;

qiPairwiseCoprime := proc(m :: list(posint), M :: integer, $) :: boolean;
    local n,i,j;
    n := nops(m);
    for i from 1 to n do
        if not isNonResidue(M, m) then return false; fi;
        for j from i + 1 to n do
            if m[i] = m[j] then return false; fi;
        od;
    od;
    return true;
end proc;


mulmod := proc(ls :: list(integer), p :: posint, $) :: integer;
    return foldl( (a,b) -> a*b mod p, 1, op(ls) );
end proc;


qimulmod := proc(ls :: list(quad_int), M :: integer, p :: posint, $) :: integer;
    return foldl( (a,b) -> qimul(a, b, M) mod p, [1, 0], op(ls) );
end proc;


Garner := proc(
        u :: list(integer),
        m :: list(posint),
        { garner_coeffs:=NULL },
        $) :: integer;

    #option trace;
    local n,recip,tmp,k,v,j,res;

    n := nops(u);

    ASSERT(n = nops(m), "Input lists must have the same length");
    ASSERT(PairwiseCoprime(m), "Moduli must be pairwise distinct and coprime");

    # Compute required reciprocals
    recip := Array(2..n, i -> 1/mulmod(m[1..i-1], m[i]) mod m[i]);

    # Compute the mixed radix coeffs
    v := Array(1..n);
    v[1] := u[1];
    for k from 2 to n do
        tmp := v[k - 1];
        for j from k - 2 to 1 by -1 do
            tmp := tmp*m[j] + v[j] mod m[k];
        od;
        v[k] := (u[k] - tmp)*recip[k] mod m[k];
    od;

    if has([_passed], 'garner_coeffs') then
        garner_coeffs := copy(v);
    fi;
    # Convert from mixed radix rep to standard rep
    res := v[n];
    for k from n - 1 to 1 by -1 do
        res := res*m[k] + v[k];
    od;

    return res;
end proc;


MixedCoeffs := proc(
        u :: list(integer),
        m :: list(posint),
        $) :: list(integer);
    
    local n,v,i,this_coeff;

    n := nops(u);
    ASSERT(n = nops(m), "Input lists must have the same size");
    
    if n = 1 then return u; fi;

    v := procname(u[..n-1], m[..n-1]);
    this_coeff := (u[n] - add( v[i]*mul(m[..i-1]), i=1..n-1 )) / mul(m[..n-1]) mod m[n];

    return [ op(v), this_coeff ];
end proc;


qicrt := proc(u :: list(quad_int), m :: list(posint), M :: integer, $) :: quad_int;
    local n,recip,tmp,k,v,j,res;
    option trace;

    n := nops(u);

    ASSERT(n = nops(m), "Input lists must have the same length");
    ASSERT(qiPairwiseCoprime(m, M), "Moduli must be pairwise distinct inert primes");

    # compute required reciprocals
    recip := Array(2..n, i -> lift(1/mulmod(m[1..i-1], m[i]) mod m[i]));

    # compute the mixed radix coeffs
    v := Array(1..n);
    v[1] := u[1];
    for k from 2 to n do
        tmp := v[k - 1];
        for j from k - 2 to 1 by -1 do
            #tmp := tmp*m[j] + v[j] mod m[k];
            tmp := qiadd(qimul(tmp, lift(m[j]), M), v[j]) mod m[k];
        od;
        #v[k] := (u[k] - tmp)*recip[k] mod m[k];
        v[k] := qimul(qisub(u[k], tmp), recip[k], M) mod m[k];
    od;

    # convert from mixed radix rep to standard rep
    res := v[n];
    for k from n - 1 to 1 by -1 do
        #res := res*m[k] + v[k];
        res := qiadd(qimul(res, lift(m[k]), M), v[k]);
    od;

    return res;
end proc;


qicrt_Example := proc($)
    local M,u,m,res,i;

    # Do the real CRT
    M := 17;
    u, m := [[3, 18], [30, 3], [5653, 63]], [31, 41, 492757];
    res := qicrt([[3, 18], [30, 3], [5653, 63]], [31, 41, 492757], 17);
    for i to 3 do print(u[i], res mod m[i]); od;

    # Since the prime ideals we are working modulo are generated by integer
    # primes, the Quadratic integer CRT is of course equivalent to doing the
    # integer one pointwise.
    print("Actual", res);
    print("Pointwise integer", chrem(u, m));
end proc;
